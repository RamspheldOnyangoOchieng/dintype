import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/utils/supabase/server';
import { createAdminClient } from '@/lib/supabase-admin';

export async function GET(request: NextRequest) {
    try {
        const { searchParams } = new URL(request.url);
        const characterId = searchParams.get('characterId');

        if (!characterId) {
            return NextResponse.json({ error: 'Character ID is required' }, { status: 400 });
        }

        const supabase = await createClient();
        const supabaseAdmin = await createAdminClient();

        if (!supabaseAdmin) {
            return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });
        }

        // Get current user (optional - for checking unlocks)
        const { data: { user } } = await supabase.auth.getUser();

        // Fetch all images from character_gallery table
        const { data: galleryImages, error: galleryError } = await supabaseAdmin
            .from('character_gallery')
            .select('*')
            .eq('character_id', characterId)
            .order('sort_order', { ascending: true })
            .order('created_at', { ascending: false })
            .range(0, 4999);

        if (galleryError) {
            console.error('Error fetching character_gallery:', galleryError);
            return NextResponse.json({ error: 'Failed to fetch gallery' }, { status: 500 });
        }

        // Fetch the character's main profile image
        const { data: character } = await supabaseAdmin
            .from('characters')
            .select('image, name')
            .eq('id', characterId)
            .single();

        // If user is logged in, check which images they've unlocked
        let unlockedImageIds: string[] = [];
        if (user) {
            const { data: userUnlocks } = await supabaseAdmin
                .from('user_unlocked_images')
                .select('gallery_image_id')
                .eq('user_id', user.id);

            unlockedImageIds = userUnlocks?.map(u => u.gallery_image_id) || [];
        }

        // Process images
        const galleryItems = (galleryImages || []).map(img => {
            const isUnlockedByUser = unlockedImageIds.includes(img.id);
            const isFreePreview = img.is_free_preview === true;
            const isGeneratedByUser = user && img.generated_by === user.id;

            // Can view if: free preview, unlocked by user, generated by user, or not locked
            const canView = isFreePreview || isUnlockedByUser || isGeneratedByUser || !img.is_locked;

            return {
                id: img.id,
                characterId: img.character_id,
                imageUrl: img.image_url,
                thumbnailUrl: img.thumbnail_url || img.image_url,
                isLocked: img.is_locked && !canView,
                isNsfw: img.is_nsfw || false,
                unlockCost: img.unlock_cost || 100,
                isFreePreview: isFreePreview,
                isUnlockedByUser,
                isOwnImage: isGeneratedByUser || false,
                createdAt: img.created_at
            };
        });

        // Add the main profile image to the gallery if it exists
        const allImages = [...galleryItems];
        if (character && character.image) {
            // Check if it's already in the gallery by URL (optional, but good for cleanliness)
            const isAlreadyInGallery = galleryItems.some(img => img.imageUrl === character.image);

            if (!isAlreadyInGallery) {
                allImages.unshift({
                    id: `${characterId}_profile`,
                    characterId: characterId,
                    imageUrl: character.image,
                    thumbnailUrl: character.image,
                    isLocked: false, // Main profile image is always unlocked
                    isNsfw: false,
                    unlockCost: 0,
                    isFreePreview: true,
                    isUnlockedByUser: true,
                    isOwnImage: true,
                    createdAt: new Date().toISOString()
                });
            }
        }

        // Count stats
        const totalImages = allImages.length;
        const unlockedCount = allImages.filter(img => !img.isLocked).length;
        const lockedCount = totalImages - unlockedCount;

        return NextResponse.json({
            images: allImages,
            stats: {
                total: totalImages,
                unlocked: unlockedCount,
                locked: lockedCount
            }
        });

    } catch (error) {
        console.error('Gallery API error:', error);
        return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
    }
}
