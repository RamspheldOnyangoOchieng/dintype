import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/utils/supabase/server';
import { createAdminClient } from '@/lib/supabase-admin';

export async function GET(request: NextRequest) {
    try {
        const { searchParams } = new URL(request.url);
        const characterId = searchParams.get('characterId');

        if (!characterId) {
            return NextResponse.json({ error: 'Character ID is required' }, { status: 400 });
        }

        const supabase = await createClient();
        const supabaseAdmin = await createAdminClient();

        if (!supabaseAdmin) {
            return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });
        }

        // Get current user (optional - for checking unlocks)
        const { data: { user } } = await supabase.auth.getUser();

        // Fetch all images from character_gallery table
        const { data: galleryImages, error: galleryError } = await supabaseAdmin
            .from('character_gallery')
            .select('*')
            .eq('character_id', characterId)
            .order('sort_order', { ascending: true })
            .order('created_at', { ascending: false })
            .range(0, 4999);

        if (galleryError) {
            console.error('Error fetching character_gallery:', galleryError);
            return NextResponse.json({ error: 'Failed to fetch gallery' }, { status: 500 });
        }

        // Fetch the character's main profile image
        const { data: character } = await supabaseAdmin
            .from('characters')
            .select('image, name')
            .eq('id', characterId)
            .single();

        // If user is logged in, check which images they've unlocked
        let unlockedImageIds: string[] = [];
        if (user) {
            const { data: userUnlocks } = await supabaseAdmin
                .from('user_unlocked_images')
                .select('gallery_image_id')
                .eq('user_id', user.id);

            unlockedImageIds = userUnlocks?.map(u => u.gallery_image_id) || [];
        }

        // Check if user is admin
        let isAdmin = false;
        if (user) {
            const { data: adminRecord } = await supabaseAdmin
                .from('admin_users')
                .select('id')
                .eq('user_id', user.id)
                .maybeSingle();
            isAdmin = !!adminRecord;
        }

        // Process images
        const galleryItems = (galleryImages || []).map(img => {
            const isUnlockedByUser = unlockedImageIds.includes(img.id);
            const isFreePreview = img.is_free_preview === true;
            const isGeneratedByUser = user && img.generated_by === user.id;

            // Can view if: admin, free preview, unlocked by user, generated by user, or not locked
            const canView = isAdmin || isFreePreview || isUnlockedByUser || isGeneratedByUser || !img.is_locked;

            return {
                id: img.id,
                characterId: img.character_id,
                imageUrl: img.image_url,
                thumbnailUrl: img.thumbnail_url || img.image_url,
                isLocked: img.is_locked && !canView,
                isNsfw: img.is_nsfw || false,
                isPrimary: img.is_primary || false,
                unlockCost: img.unlock_cost || 100,
                isFreePreview: isFreePreview,
                isUnlockedByUser,
                isOwnImage: isGeneratedByUser || false,
                createdAt: img.created_at
            };
        });

        // Add the main profile image to the gallery if it exists
        const allImages = [...galleryItems];
        if (character && character.image) {
            // Check if it's already in the gallery by URL (optional, but good for cleanliness)
            const matchedGalleryItem = galleryItems.find(img => img.imageUrl === character.image);

            if (matchedGalleryItem) {
                // If it's already in gallery, ensure it's marked as primary if it matches characters.image
                matchedGalleryItem.isPrimary = true;
            } else {
                allImages.unshift({
                    id: `${characterId}_profile`,
                    characterId: characterId,
                    imageUrl: character.image,
                    thumbnailUrl: character.image,
                    isLocked: false, // Main profile image is always unlocked
                    isNsfw: false,
                    isPrimary: true,
                    unlockCost: 0,
                    isFreePreview: true,
                    isUnlockedByUser: true,
                    isOwnImage: true,
                    createdAt: new Date().toISOString()
                });
            }
        }

        // Count stats
        const totalImages = allImages.length;
        const unlockedCount = allImages.filter(img => !img.isLocked).length;
        const lockedCount = totalImages - unlockedCount;

        return NextResponse.json({
            images: allImages,
            stats: {
                total: totalImages,
                unlocked: unlockedCount,
                locked: lockedCount
            }
        });

    } catch (error) {
        console.error('Gallery API error:', error);
        return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
    }
}

export async function POST(request: NextRequest) {
    try {
        const body = await request.json();
        const { characterId, imageUrl, thumbnail_url, isLocked, isNsfw, sortOrder, isPrimary } = body;

        if (!characterId || !imageUrl) {
            return NextResponse.json({ error: 'Character ID and Image URL are required' }, { status: 400 });
        }

        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        // Check if user is admin
        if (!user) {
            return NextResponse.json({ error: 'Authentication required' }, { status: 401 });
        }

        const supabaseAdmin = await createAdminClient();
        if (!supabaseAdmin) {
            return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });
        }
        const { data: adminRecord } = await supabaseAdmin
            .from('admin_users')
            .select('id')
            .eq('user_id', user.id)
            .single();

        if (!adminRecord) {
            return NextResponse.json({ error: 'Admin access required' }, { status: 403 });
        }

        // If setting as primary, reset others first
        if (isPrimary) {
            await supabaseAdmin
                .from('character_gallery')
                .update({ is_primary: false })
                .eq('character_id', characterId);

            // Also update character main image
            await supabaseAdmin
                .from('characters')
                .update({ image: imageUrl })
                .eq('id', characterId);
        }

        // Insert into character_gallery
        const { data, error } = await supabaseAdmin
            .from('character_gallery')
            .insert([{
                character_id: characterId,
                image_url: imageUrl,
                thumbnail_url: thumbnail_url || imageUrl,
                is_locked: isLocked ?? true,
                is_nsfw: isNsfw ?? false,
                is_primary: isPrimary ?? false,
                sort_order: sortOrder ?? 0,
                created_at: new Date().toISOString()
            }])
            .select()
            .single();

        if (error) {
            console.error('Error adding to gallery:', error);
            return NextResponse.json({ error: 'Failed to add image to gallery' }, { status: 500 });
        }

        return NextResponse.json(data);

    } catch (error) {
        console.error('Gallery POST error:', error);
        return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
    }
}

export async function DELETE(request: NextRequest) {
    try {
        const { searchParams } = new URL(request.url);
        const imageId = searchParams.get('id');

        if (!imageId) {
            return NextResponse.json({ error: 'Image ID is required' }, { status: 400 });
        }

        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return NextResponse.json({ error: 'Authentication required' }, { status: 401 });
        }

        const supabaseAdmin = await createAdminClient();
        if (!supabaseAdmin) {
            return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });
        }

        const { data: adminRecord } = await supabaseAdmin
            .from('admin_users')
            .select('id')
            .eq('user_id', user.id)
            .single();

        if (!adminRecord) {
            return NextResponse.json({ error: 'Admin access required' }, { status: 403 });
        }

        // Get the image first to find the URL
        const { data: image } = await supabaseAdmin
            .from('character_gallery')
            .select('image_url')
            .eq('id', imageId)
            .single();

        // Delete from DB
        const { error } = await supabaseAdmin
            .from('character_gallery')
            .delete()
            .eq('id', imageId);

        if (error) {
            console.error('Error deleting from gallery:', error);
            return NextResponse.json({ error: 'Failed to delete image' }, { status: 500 });
        }

        // Optionally delete from Cloudinary
        if (image?.image_url?.includes('cloudinary.com')) {
            try {
                const { getPublicIdFromUrl, deleteImageFromCloudinary } = await import("@/lib/cloudinary-actions")
                const publicId = await getPublicIdFromUrl(image.image_url)
                if (publicId) {
                    await deleteImageFromCloudinary(publicId)
                }
            } catch (e) {
                console.warn('Failed to delete from Cloudinary:', e)
            }
        }

        return NextResponse.json({ success: true });

    } catch (error) {
        console.error('Gallery DELETE error:', error);
        return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
    }
}

export async function PATCH(request: NextRequest) {
    try {
        const body = await request.json();
        const { id, characterId, isPrimary } = body;

        if (!id || !characterId) {
            return NextResponse.json({ error: 'ID and Character ID are required' }, { status: 400 });
        }

        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return NextResponse.json({ error: 'Authentication required' }, { status: 401 });
        }

        const supabaseAdmin = await createAdminClient();
        if (!supabaseAdmin) {
            return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });
        }

        const { data: adminRecord } = await supabaseAdmin
            .from('admin_users')
            .select('id')
            .eq('user_id', user.id)
            .single();

        if (!adminRecord) {
            return NextResponse.json({ error: 'Admin access required' }, { status: 403 });
        }

        // If setting as primary
        if (isPrimary) {
            // 1. Reset all other images for this character
            await supabaseAdmin
                .from('character_gallery')
                .update({ is_primary: false })
                .eq('character_id', characterId);

            // 2. Set this image as primary
            const { data: updatedImage, error: updateError } = await supabaseAdmin
                .from('character_gallery')
                .update({ is_primary: true })
                .eq('id', id)
                .select()
                .single();

            if (updateError) {
                console.error('Error setting primary:', updateError);
                return NextResponse.json({ error: 'Failed to set primary image' }, { status: 500 });
            }

            // 3. Update the main character table
            if (updatedImage) {
                await supabaseAdmin
                    .from('characters')
                    .update({
                        image: updatedImage.image_url,
                        image_url: updatedImage.image_url
                    })
                    .eq('id', characterId);
            }

            return NextResponse.json({ success: true, image: updatedImage });
        }

        return NextResponse.json({ error: 'Nothing to update' }, { status: 400 });

    } catch (error) {
        console.error('Gallery PATCH error:', error);
        return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
    }
}
